{"version":11,"variables":[{"key":"HostKPI","type":"csv","input":"cpu,memory","multiple":false},{"key":"ApplicationKPI","type":"csv","input":"Duration,VisuallyCompleteTime,SpeedIndex,LoadEventEnd,FirstInputDelay,CumulativeLayoutShift,LargestContentfulPaint,CdnBusyTime,CdnResources,DocumentInteractiveTime,DomCompleteTime,DomContentLoadedTime,FirstPartyBusyTime,FirstPartyResources,FrontendTime,LoadEventStart,NavigationStart,NetworkTime,RequestStart,ResponseEnd,ResponseStart,ServerTime,ThirdPartyBusyTime,ThirdPartyResources","multiple":false},{"key":"ServiceKPI","type":"csv","input":"ErrorRate,ResponseTime","multiple":false}],"tiles":{"9":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"10":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"12":{"type":"markdown","title":"","content":"![](data:image/webp;base64,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)"},"14":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"20":{"type":"code","title":"Overall Health","input":"const From=$dt_timeframe_from;\nconst To=$dt_timeframe_to;\nvar healthCount=0;\nconst metric = \"builtin:host.net.nic.packets.errorsRx\";\nlet totalVal = 0;\nimport { rumUserSessionsClient } from '@dynatrace-sdk/client-classic-environment-v1';\nimport { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport { metricsClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\nimport { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\nimport { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\nasync function getProblemsList() {\n  \n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n    from: startTime,to: endTime, problemSelector: \"status(Closed)\"\n  });\n  const result = await response;\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n// Start Logs\n  const timeout = 60;\n  var query = 'fetch logs, timeframe:\"'+$dt_timeframe_from+'/'+$dt_timeframe_to+'\" | summarize {logCount = count(), errorCount = countIf(status == \"ERROR\")} | fieldsAdd errorRate = (toDouble(errorCount) / toDouble(logCount)) * 100 | fields errorRate';\n  const query_response = await queryExecutionClient.queryExecute({ body: { query, requestTimeoutMilliseconds: timeout * 1000, fetchTimeoutSeconds: timeout  } });\n  const errorRate = parseInt(query_response.result[\"records\"][0][\"errorRate\"]);\n  if (errorRate>10) healthCount=healthCount+3;\n  if (errorRate>3) healthCount=healthCount+1;\n// End Logs\n \n// Start Security\nasync function pollQuery(requestToken, resolve) {\n\n  const poll = await queryExecutionClient.queryPoll({requestToken, requestTimeoutMilliseconds: 3000});\n  if(poll.result) {\n      resolve(poll.result);\n  } else {\n      pollQuery(requestToken, resolve);\n  }\n}\nfunction runQuery (query) {\n  return new Promise(async (resolve, reject) => {\n\n      const queryExecution = await queryExecutionClient.queryExecute({body: { query }});\n      if(queryExecution.result) {\n          resolve(queryExecution.result);\n      } else {\n          pollQuery(queryExecution.requestToken, resolve)\n      }\n\n  });\n}\n\n const commonFilterQueryPart =\n `fetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n// filter only the latest snapshot data\n| fieldsAdd matcher=\"match\"\n| lookup [\nfetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n| fields \nmaxTimestamp=timestamp,\nmatcher=\"match\"\n| limit 1\n], sourceField:matcher, lookupField:matcher\n| filter timestamp==lookup.maxTimestamp\n//end of filtering for the latest snapshot`;\n \n const vulnBySeverityQueryString = `${commonFilterQueryPart}\n | summarize \n   Muted=takeFirst(vulnerability.mute.status==\"MUTED\"), \n   vulnerability.risk.level=takeFirst(vulnerability.risk.level), \n   by: {vulnerability.display_id, timestamp} \n | summarize \n C=countIf(vulnerability.risk.level==\"CRITICAL\" AND Muted==FALSE), \n H=countIf(vulnerability.risk.level==\"HIGH\" AND Muted==FALSE), \n M=countIf(vulnerability.risk.level==\"MEDIUM\" AND Muted==FALSE), \n L=countIf(vulnerability.risk.level==\"LOW\" AND Muted==FALSE), \n by: {timestamp} \n | summarize  \n C=takeLast(C), \n H=takeLast(H), \n M=takeLast(M), \n L=takeLast(L)`;\n \n const avgRiskScoreQueryString = `${commonFilterQueryPart}\n | summarize \n  Risk = takeFirst(vulnerability.risk.level), \n  Muted=takeFirst(vulnerability.mute.status), \n  RiskScore=takeFirst(vulnerability.risk.score), \n  by: {vulnerability.display_id, timestamp} \n | filterOut Muted == \"MUTED\"\n | summarize \n  average=avg(RiskScore), \n  by: {risk=Risk, timestamp} \n | summarize average=takeLast(average), \n by: {risk}`;\n \n \n  // Get the counts per risk level using DQL\n  console.log(vulnBySeverityQueryString);\n  const vulnBySeverityQueryResult = await runQuery(vulnBySeverityQueryString); \n  \n  if (vulnBySeverityQueryResult.records == null || vulnBySeverityQueryResult.records.length==0){\n    return \"No Data\";\n  }\n  const vulnBySeverity=vulnBySeverityQueryResult.records[0];\n  \n    // Define data set: Number of problems per criticality level\n  \n    // Get the avg score per risk level using DQL\n  const avgRiskScoreQueryResult = await runQuery(avgRiskScoreQueryString);\n  \n  const avgRiskScore=avgRiskScoreQueryResult.records.reduce((obj,record)=>{\n      \n    if(record == null ||  obj == null || record.average == null) return;\n    if(record.risk==\"CRITICAL\"){\n      obj.C=record.average;\n    }\n    if(record.risk==\"HIGH\"){\n      obj.H=record.average;\n    }\n    if(record.risk==\"MEDIUM\"){\n      obj.M=record.average;\n    }\n    if(record.risk==\"LOW\"){\n      obj.L=record.average;\n    }\n    return obj;\n  },{\"C\":0,\"H\":0,\"M\":0,\"L\":0});\n\n  // Define weights of the criticality level. Higher weight means that the contribution in the highest criticality level is higher.\n  const weights = {\n    \"C\": 60,\n    \"H\": 20,\n    \"M\": 5,\n    \"L\": 1,\n  };\n \n  // Define ranges for the criticality levels\n  const scoreRanges = {\n      \"C\": [9, 10],\n      \"H\": [7, 9],\n      \"M\": [4, 7],\n      \"L\": [0.5, 4],\n    };\n \n \n  // Normalize the average risk score of each severity against the score range of that severity (output between 0 and 1).\n  const normalizedAvgSeverities={}\n  for(const[severity, avg] of Object.entries(avgRiskScore)){\n    const minScore=scoreRanges[severity][0];\n    const maxScore=scoreRanges[severity][1];\n    const scoreRange=maxScore-minScore;\n    normalizedAvgSeverities[severity]=(avgRiskScore[severity]-minScore)/scoreRange;\n  }\n    // Define logistic function and scale to make sense of the amount of problems in a criticality level (output is always between 0 and 1)\n    const scale=10\n    function logistic(x) {\n      return Math.tanh(x/scale)\n    }\n  \n    const severities = Object.keys(vulnBySeverity);\n   \n    let score=0;\n    let minScore=0;\n    let maxScore=0;\n   \n    const unrelevantSeverities=[];\n   \n    // Calculate min/max and the distance between min and max (the final score range) in the highest available criticality level\n    for (const severity of severities) {\n      if (vulnBySeverity[severity] >= 1) {\n        minScore=scoreRanges[severity][0];\n        maxScore=scoreRanges[severity][1];\n        break;\n      }else{\n        // Remove all severities that are above the maximum range to have a better result for lower scores\n        unrelevantSeverities.push(severity); \n      }\n    }\n    const scoreRange=maxScore-minScore;\n   \n    const relevantWeights=Object.fromEntries(Object.entries(weights).filter(([severity,weight]) => !unrelevantSeverities.includes(severity)));\n    const relevantSeverities=severities.filter((severity,weight) => !unrelevantSeverities.includes(severity));\n   \n    \n    // Convert weights into percentage based ratios\n    const weightRatios={};\n    let totalWeight = Object.values(relevantWeights).reduce((acc, number) => acc + number, 0);\n    for(const[severity, weight] of Object.entries(relevantWeights)){\n      weightRatios[severity]=weight/totalWeight;\n    }\n   \n    // Increase the min score of the highest criticality level by the score contribution of each criticality level (based on weight and count)\n    let addedScore=0;\n    for(const severity of relevantSeverities){\n      const maxAddedScore=weightRatios[severity]*scoreRange;\n      const scoreContribution=maxAddedScore*logistic(vulnBySeverity[severity])*normalizedAvgSeverities[severity];\n      addedScore+=scoreContribution\n    }\n   \n    // Calculate final score\n    const finalScore= (minScore + addedScore)*10;\n    let scoreStr=finalScore.toPrecision(2);\n    if (scoreStr>89)\n      healthCount=healthCount+3;\n    if (scoreStr>70)\n      healthCount=healthCount+1;\n// End Security\n// Start Service\n  try{\n    const healthyS = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const badS = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    if (((healthyS.totalCount *100) / (healthyS.totalCount + badS.totalCount)).toFixed(2)<100)\n      healthCount=healthCount+3;\n  }\n  catch(e){\n    console.log(e);\n  }\n// End Service\n// Start Host\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    if (((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(2)<100)\n      healthCount=healthCount+3;\n  }\n  catch(e){\n    console.log(e);\n  }\n// End Host\n// Start Application\n  const startTime2 = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime2 = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  var query = 'SELECT CONDITION (count(*),WHERE userexperiencescore=\"SATISFIED\"), CONDITION (count(*),WHERE userexperiencescore=\"TOLERATED\"), CONDITION (count(*),WHERE userexperiencescore=\"FRUSTRATED\") FROM usersession where starttime>='+startTime2+' and endtime<='+endTime2;\n  const result = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime2, endTimestamp: endTime2});\n  if (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2]))*100<80)\n    healthCount=healthCount+3;\n  if (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2]))*100<92)\n    healthCount=healthCount+1;\n// End Application\n// Start Network\n  try{\n    const config = {\n      acceptType: \"application/json; charset=utf-8\",\n      metricSelector: metric,\n      resolution: \"inf\",\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString()\n    }\n    const data = await metricsClient.query(config);\n    console.log(data.result[0].data);\n    (data.result[0].data).map(result => {\n      totalVal += result.values[0];\n    });\n    if (totalVal>0) healthCount=healthCount+3;\n  }\n  catch(e){\n    console.log(e);\n  }\n// End Network\n// Start Davis \n  const response = await getProblemsList();\n  const problems=response;\n  const types = [{\n      mappings: {\n        startTime: {type: 'timestamp'},\n        status: {type: 'string'},\n        displayId: {type: 'string'},\n        title: {type: 'string'},\n        impactLevel: {type: 'string'},\n        severityLevel: {type: 'string'},\n        affectedEntities: {type: 'string'},\n        impactedEntities: {type: 'string'},\n        rootCauseEntity: {type: 'string'},\n        duration: {type: 'double'},\n        \"event.id\": {type: 'string'},\n        endTime: {type: 'timestamp'}\n        },\n        indexRange: [\n        0,\n        problems.length\n      ]\n  }]\n  // Create a new empty data frame for the result\n  const dataFrame = {\n    records: [],\n    types: types\n  }\n  var mttr = 0;\n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      mttr = mttr + duration;\n      var pstatus = \"\";\n      if (problem.status == 'OPEN') {\n        pstatus = \"ðŸ”´ OPEN\";\n      } else {\n        pstatus = 'ðŸŸ¢ CLOSED';\n      }\n      var affectedEntities = expandArray(problem.affectedEntities);\n      var impactedEntities = expandArray(problem.impactedEntities);\n      var rootCause = \"\";\n      if (problem.rootCauseEntity == null) {\n        rootCause = \"\"\n      } else {\n        rootCause = problem.rootCauseEntity[\"name\"];\n      }\n       const record = {\n              startTime: problem.startTime,\n              status: pstatus,\n              displayId: problem.displayId,\n              title: problem.title,\n              impactLevel: problem.impactLevel,\n              severityLevel: problem.severityLevel,\n              affectedEntities: affectedEntities,\n              impactedEntities: impactedEntities,\n              rootCauseEntity: rootCause,\n              duration: duration,\n              \"event.id\": problem.problemId,\n              endTime: problem.endTime\n            }\n        dataFrame.records.push(record);\n    }\n//  return dataFrame;\n  if ((mttr/problems.length)>60) healthCount=healthCount+3;\n  if ((mttr/problems.length)>30) healthCount=healthCount+1;\n// End Davis \n\n  if (healthCount>2)\n    return \"ðŸ”´\";\n  if (healthCount>0)\n    return \"ðŸŸ¡\";\n  return \"ðŸŸ¢\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"24":{"type":"code","title":"Application Health","input":"import { rumUserSessionsClient } from '@dynatrace-sdk/client-classic-environment-v1';\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const query = 'SELECT CONDITION (count(*),WHERE userexperiencescore=\"SATISFIED\"), CONDITION (count(*),WHERE userexperiencescore=\"TOLERATED\"), CONDITION (count(*),WHERE userexperiencescore=\"FRUSTRATED\") FROM usersession where starttime>='+startTime+' and endtime<='+endTime;\n  const result = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  if (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2]))*100<80)\n    return \"ðŸ”´\";\n  if (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2]))*100<92)\n    return \"ðŸŸ¡\";\n  return \"ðŸŸ¢\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"sparklineSettings":{"isVisible":false},"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"25":{"type":"code","title":"Host (% Healthy)","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function fetchMetricResults() {\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    return ((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(0) + \" %\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[{"id":1,"field":"","title":"","isEnabled":true,"rules":[{"id":0,"color":{"Default":"var(--dt-colors-charts-categorical-color-09-default, #649438)"},"comparator":"â‰¥","label":"","value":100},{"id":2,"color":{"Default":"var(--dt-colors-charts-categorical-color-12-default, #cd3741)"},"comparator":"â‰¥","label":"","value":0}]}],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"26":{"type":"code","title":"Host Health","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function fetchMetricResults() {\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    if (((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(2)<100)\n      return \"ðŸ”´\";\n    else \n      return \"ðŸŸ¢\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"27":{"type":"code","title":"Service (% Healthy)","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function fetchMetricResults() {\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    return ((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(0) + \" %\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"28":{"type":"code","title":"Service Health","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function fetchMetricResults() {\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    if (((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(2)<100)\n      return \"ðŸ”´\";\n    else \n      return \"ðŸŸ¢\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"33":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"34":{"type":"code","title":"Davis Health","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getProblemsList() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n    from: startTime,to: endTime, problemSelector: \"status(Closed)\"\n  });\n  const result = await response;\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n  const response = await getProblemsList();\n  const problems=response;\n  const types = [{\n      mappings: {\n        startTime: {type: 'timestamp'},\n        status: {type: 'string'},\n        displayId: {type: 'string'},\n        title: {type: 'string'},\n        impactLevel: {type: 'string'},\n        severityLevel: {type: 'string'},\n        affectedEntities: {type: 'string'},\n        impactedEntities: {type: 'string'},\n        rootCauseEntity: {type: 'string'},\n        duration: {type: 'double'},\n        \"event.id\": {type: 'string'},\n        endTime: {type: 'timestamp'}\n        },\n        indexRange: [\n        0,\n        problems.length\n      ]\n  }]\n  // Create a new empty data frame for the result\n  const dataFrame = {\n    records: [],\n    types: types\n  }\n  var mttr = 0;\n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      mttr = mttr + duration;\n      var pstatus = \"\";\n      if (problem.status == 'OPEN') {\n        pstatus = \"ðŸ”´ OPEN\";\n      } else {\n        pstatus = 'ðŸŸ¢ CLOSED';\n      }\n      var affectedEntities = expandArray(problem.affectedEntities);\n      var impactedEntities = expandArray(problem.impactedEntities);\n      var rootCause = \"\";\n      if (problem.rootCauseEntity == null) {\n        rootCause = \"\"\n      } else {\n        rootCause = problem.rootCauseEntity[\"name\"];\n      }\n       const record = {\n              startTime: problem.startTime,\n              status: pstatus,\n              displayId: problem.displayId,\n              title: problem.title,\n              impactLevel: problem.impactLevel,\n              severityLevel: problem.severityLevel,\n              affectedEntities: affectedEntities,\n              impactedEntities: impactedEntities,\n              rootCauseEntity: rootCause,\n              duration: duration,\n              \"event.id\": problem.problemId,\n              endTime: problem.endTime\n            }\n        dataFrame.records.push(record);\n    }\n//  return dataFrame;\n  if ((mttr/problems.length)>60) return \"ðŸ”´\";\n  if ((mttr/problems.length)>30) return \"ðŸŸ¡\";\n  return \"ðŸŸ¢\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"36":{"type":"code","title":"Network Health","input":"import { metricsClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nconst metric = \"builtin:host.net.nic.packets.errorsRx\";\nlet totalVal = 0;\n\nexport default async function main() {\n  try{\n    const config = {\n      acceptType: \"application/json; charset=utf-8\",\n      metricSelector: metric,\n      resolution: \"inf\",\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString()\n    }\n    const data = await metricsClient.query(config);\n    console.log(data.result[0].data);\n    (data.result[0].data).map(result => {\n      totalVal += result.values[0];\n    });\n    if (totalVal>0)\n      return \"ðŸ”´\";\n    return \"ðŸŸ¢\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"37":{"type":"code","title":"Security Health","input":"const From=$dt_timeframe_from;\nconst To=$dt_timeframe_to;\nimport { queryExecutionClient } from '@dynatrace-sdk/client-query';\nexport default async function () {\nasync function pollQuery(requestToken, resolve) {\n\n  const poll = await queryExecutionClient.queryPoll({requestToken, requestTimeoutMilliseconds: 3000});\n  if(poll.result) {\n      resolve(poll.result);\n  } else {\n      pollQuery(requestToken, resolve);\n  }\n}\nfunction runQuery (query) {\n  return new Promise(async (resolve, reject) => {\n\n      const queryExecution = await queryExecutionClient.queryExecute({body: { query }});\n      if(queryExecution.result) {\n          resolve(queryExecution.result);\n      } else {\n          pollQuery(queryExecution.requestToken, resolve)\n      }\n\n  });\n}\n\n const commonFilterQueryPart =\n `fetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n// filter only the latest snapshot data\n| fieldsAdd matcher=\"match\"\n| lookup [\nfetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n| fields \nmaxTimestamp=timestamp,\nmatcher=\"match\"\n| limit 1\n], sourceField:matcher, lookupField:matcher\n| filter timestamp==lookup.maxTimestamp\n//end of filtering for the latest snapshot`;\n \n const vulnBySeverityQueryString = `${commonFilterQueryPart}\n | summarize \n   Muted=takeFirst(vulnerability.mute.status==\"MUTED\"), \n   vulnerability.risk.level=takeFirst(vulnerability.risk.level), \n   by: {vulnerability.display_id, timestamp} \n | summarize \n C=countIf(vulnerability.risk.level==\"CRITICAL\" AND Muted==FALSE), \n H=countIf(vulnerability.risk.level==\"HIGH\" AND Muted==FALSE), \n M=countIf(vulnerability.risk.level==\"MEDIUM\" AND Muted==FALSE), \n L=countIf(vulnerability.risk.level==\"LOW\" AND Muted==FALSE), \n by: {timestamp} \n | summarize  \n C=takeLast(C), \n H=takeLast(H), \n M=takeLast(M), \n L=takeLast(L)`;\n \n const avgRiskScoreQueryString = `${commonFilterQueryPart}\n | summarize \n  Risk = takeFirst(vulnerability.risk.level), \n  Muted=takeFirst(vulnerability.mute.status), \n  RiskScore=takeFirst(vulnerability.risk.score), \n  by: {vulnerability.display_id, timestamp} \n | filterOut Muted == \"MUTED\"\n | summarize \n  average=avg(RiskScore), \n  by: {risk=Risk, timestamp} \n | summarize average=takeLast(average), \n by: {risk}`;\n \n \n  // Get the counts per risk level using DQL\n  console.log(vulnBySeverityQueryString);\n  const vulnBySeverityQueryResult = await runQuery(vulnBySeverityQueryString); \n  \n  if (vulnBySeverityQueryResult.records == null || vulnBySeverityQueryResult.records.length==0){\n    return \"No Data\";\n  }\n  const vulnBySeverity=vulnBySeverityQueryResult.records[0];\n  \n    // Define data set: Number of problems per criticality level\n  \n    // Get the avg score per risk level using DQL\n  const avgRiskScoreQueryResult = await runQuery(avgRiskScoreQueryString);\n  \n  const avgRiskScore=avgRiskScoreQueryResult.records.reduce((obj,record)=>{\n      \n    if(record == null ||  obj == null || record.average == null) return;\n    if(record.risk==\"CRITICAL\"){\n      obj.C=record.average;\n    }\n    if(record.risk==\"HIGH\"){\n      obj.H=record.average;\n    }\n    if(record.risk==\"MEDIUM\"){\n      obj.M=record.average;\n    }\n    if(record.risk==\"LOW\"){\n      obj.L=record.average;\n    }\n    return obj;\n  },{\"C\":0,\"H\":0,\"M\":0,\"L\":0});\n\n  // Define weights of the criticality level. Higher weight means that the contribution in the highest criticality level is higher.\n  const weights = {\n    \"C\": 60,\n    \"H\": 20,\n    \"M\": 5,\n    \"L\": 1,\n  };\n \n  // Define ranges for the criticality levels\n  const scoreRanges = {\n      \"C\": [9, 10],\n      \"H\": [7, 9],\n      \"M\": [4, 7],\n      \"L\": [0.5, 4],\n    };\n \n \n  // Normalize the average risk score of each severity against the score range of that severity (output between 0 and 1).\n  const normalizedAvgSeverities={}\n  for(const[severity, avg] of Object.entries(avgRiskScore)){\n    const minScore=scoreRanges[severity][0];\n    const maxScore=scoreRanges[severity][1];\n    const scoreRange=maxScore-minScore;\n    normalizedAvgSeverities[severity]=(avgRiskScore[severity]-minScore)/scoreRange;\n  }\n    // Define logistic function and scale to make sense of the amount of problems in a criticality level (output is always between 0 and 1)\n    const scale=10\n    function logistic(x) {\n      return Math.tanh(x/scale)\n    }\n  \n    const severities = Object.keys(vulnBySeverity);\n   \n    let score=0;\n    let minScore=0;\n    let maxScore=0;\n   \n    const unrelevantSeverities=[];\n   \n    // Calculate min/max and the distance between min and max (the final score range) in the highest available criticality level\n    for (const severity of severities) {\n      if (vulnBySeverity[severity] >= 1) {\n        minScore=scoreRanges[severity][0];\n        maxScore=scoreRanges[severity][1];\n        break;\n      }else{\n        // Remove all severities that are above the maximum range to have a better result for lower scores\n        unrelevantSeverities.push(severity); \n      }\n    }\n    const scoreRange=maxScore-minScore;\n   \n    const relevantWeights=Object.fromEntries(Object.entries(weights).filter(([severity,weight]) => !unrelevantSeverities.includes(severity)));\n    const relevantSeverities=severities.filter((severity,weight) => !unrelevantSeverities.includes(severity));\n   \n    \n    // Convert weights into percentage based ratios\n    const weightRatios={};\n    let totalWeight = Object.values(relevantWeights).reduce((acc, number) => acc + number, 0);\n    for(const[severity, weight] of Object.entries(relevantWeights)){\n      weightRatios[severity]=weight/totalWeight;\n    }\n   \n    // Increase the min score of the highest criticality level by the score contribution of each criticality level (based on weight and count)\n    let addedScore=0;\n    for(const severity of relevantSeverities){\n      const maxAddedScore=weightRatios[severity]*scoreRange;\n      const scoreContribution=maxAddedScore*logistic(vulnBySeverity[severity])*normalizedAvgSeverities[severity];\n      addedScore+=scoreContribution\n    }\n   \n    // Calculate final score\n    const finalScore= (minScore + addedScore)*10;\n    let scoreStr=finalScore.toPrecision(2);\n    if (scoreStr>89)\n      return \"ðŸ”´\";\n    if (scoreStr>70)\n      return \"ðŸŸ¡\";\n    return \"ðŸŸ¢\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"38":{"type":"code","title":"Security Score","input":"const From=$dt_timeframe_from;\nconst To=$dt_timeframe_to;\nimport { queryExecutionClient } from '@dynatrace-sdk/client-query';\nexport default async function () {\nasync function pollQuery(requestToken, resolve) {\n\n  const poll = await queryExecutionClient.queryPoll({requestToken, requestTimeoutMilliseconds: 3000});\n  if(poll.result) {\n      resolve(poll.result);\n  } else {\n      pollQuery(requestToken, resolve);\n  }\n}\nfunction runQuery (query) {\n  return new Promise(async (resolve, reject) => {\n\n      const queryExecution = await queryExecutionClient.queryExecute({body: { query }});\n      if(queryExecution.result) {\n          resolve(queryExecution.result);\n      } else {\n          pollQuery(queryExecution.requestToken, resolve)\n      }\n\n  });\n}\n\n const commonFilterQueryPart =\n `fetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n// filter only the latest snapshot data\n| fieldsAdd matcher=\"match\"\n| lookup [\nfetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n| fields \nmaxTimestamp=timestamp,\nmatcher=\"match\"\n| limit 1\n], sourceField:matcher, lookupField:matcher\n| filter timestamp==lookup.maxTimestamp\n//end of filtering for the latest snapshot`;\n \n const vulnBySeverityQueryString = `${commonFilterQueryPart}\n | summarize \n   Muted=takeFirst(vulnerability.mute.status==\"MUTED\"), \n   vulnerability.risk.level=takeFirst(vulnerability.risk.level), \n   by: {vulnerability.display_id, timestamp} \n | summarize \n C=countIf(vulnerability.risk.level==\"CRITICAL\" AND Muted==FALSE), \n H=countIf(vulnerability.risk.level==\"HIGH\" AND Muted==FALSE), \n M=countIf(vulnerability.risk.level==\"MEDIUM\" AND Muted==FALSE), \n L=countIf(vulnerability.risk.level==\"LOW\" AND Muted==FALSE), \n by: {timestamp} \n | summarize  \n C=takeLast(C), \n H=takeLast(H), \n M=takeLast(M), \n L=takeLast(L)`;\n \n const avgRiskScoreQueryString = `${commonFilterQueryPart}\n | summarize \n  Risk = takeFirst(vulnerability.risk.level), \n  Muted=takeFirst(vulnerability.mute.status), \n  RiskScore=takeFirst(vulnerability.risk.score), \n  by: {vulnerability.display_id, timestamp} \n | filterOut Muted == \"MUTED\"\n | summarize \n  average=avg(RiskScore), \n  by: {risk=Risk, timestamp} \n | summarize average=takeLast(average), \n by: {risk}`;\n \n \n  // Get the counts per risk level using DQL\n  console.log(vulnBySeverityQueryString);\n  const vulnBySeverityQueryResult = await runQuery(vulnBySeverityQueryString); \n  \n  if (vulnBySeverityQueryResult.records == null || vulnBySeverityQueryResult.records.length==0){\n    return \"No Data\";\n  }\n  const vulnBySeverity=vulnBySeverityQueryResult.records[0];\n  \n    // Define data set: Number of problems per criticality level\n  \n    // Get the avg score per risk level using DQL\n  const avgRiskScoreQueryResult = await runQuery(avgRiskScoreQueryString);\n  \n  const avgRiskScore=avgRiskScoreQueryResult.records.reduce((obj,record)=>{\n      \n    if(record == null ||  obj == null || record.average == null) return;\n    if(record.risk==\"CRITICAL\"){\n      obj.C=record.average;\n    }\n    if(record.risk==\"HIGH\"){\n      obj.H=record.average;\n    }\n    if(record.risk==\"MEDIUM\"){\n      obj.M=record.average;\n    }\n    if(record.risk==\"LOW\"){\n      obj.L=record.average;\n    }\n    return obj;\n  },{\"C\":0,\"H\":0,\"M\":0,\"L\":0});\n\n  // Define weights of the criticality level. Higher weight means that the contribution in the highest criticality level is higher.\n  const weights = {\n    \"C\": 60,\n    \"H\": 20,\n    \"M\": 5,\n    \"L\": 1,\n  };\n \n  // Define ranges for the criticality levels\n  const scoreRanges = {\n      \"C\": [9, 10],\n      \"H\": [7, 9],\n      \"M\": [4, 7],\n      \"L\": [0.5, 4],\n    };\n \n \n  // Normalize the average risk score of each severity against the score range of that severity (output between 0 and 1).\n  const normalizedAvgSeverities={}\n  for(const[severity, avg] of Object.entries(avgRiskScore)){\n    const minScore=scoreRanges[severity][0];\n    const maxScore=scoreRanges[severity][1];\n    const scoreRange=maxScore-minScore;\n    normalizedAvgSeverities[severity]=(avgRiskScore[severity]-minScore)/scoreRange;\n  }\n    // Define logistic function and scale to make sense of the amount of problems in a criticality level (output is always between 0 and 1)\n    const scale=10\n    function logistic(x) {\n      return Math.tanh(x/scale)\n    }\n  \n    const severities = Object.keys(vulnBySeverity);\n   \n    let score=0;\n    let minScore=0;\n    let maxScore=0;\n   \n    const unrelevantSeverities=[];\n   \n    // Calculate min/max and the distance between min and max (the final score range) in the highest available criticality level\n    for (const severity of severities) {\n      if (vulnBySeverity[severity] >= 1) {\n        minScore=scoreRanges[severity][0];\n        maxScore=scoreRanges[severity][1];\n        break;\n      }else{\n        // Remove all severities that are above the maximum range to have a better result for lower scores\n        unrelevantSeverities.push(severity); \n      }\n    }\n    const scoreRange=maxScore-minScore;\n   \n    const relevantWeights=Object.fromEntries(Object.entries(weights).filter(([severity,weight]) => !unrelevantSeverities.includes(severity)));\n    const relevantSeverities=severities.filter((severity,weight) => !unrelevantSeverities.includes(severity));\n   \n    \n    // Convert weights into percentage based ratios\n    const weightRatios={};\n    let totalWeight = Object.values(relevantWeights).reduce((acc, number) => acc + number, 0);\n    for(const[severity, weight] of Object.entries(relevantWeights)){\n      weightRatios[severity]=weight/totalWeight;\n    }\n   \n    // Increase the min score of the highest criticality level by the score contribution of each criticality level (based on weight and count)\n    let addedScore=0;\n    for(const severity of relevantSeverities){\n      const maxAddedScore=weightRatios[severity]*scoreRange;\n      const scoreContribution=maxAddedScore*logistic(vulnBySeverity[severity])*normalizedAvgSeverities[severity];\n      addedScore+=scoreContribution\n    }\n   \n    // Calculate final score\n    const finalScore= (minScore + addedScore)*10;\n    let scoreStr=finalScore.toPrecision(2);\n    return scoreStr;\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"41":{"type":"code","title":"Application (Apdex)","input":"import { rumUserSessionsClient } from '@dynatrace-sdk/client-classic-environment-v1';\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const query = 'SELECT CONDITION (count(*),WHERE userexperiencescore=\"SATISFIED\"), CONDITION (count(*),WHERE userexperiencescore=\"TOLERATED\"), CONDITION (count(*),WHERE userexperiencescore=\"FRUSTRATED\") FROM usersession where starttime>='+startTime+' and endtime<='+endTime;\n  const result = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  return (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2])).toFixed(2));\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[{"id":1,"field":"","title":"","isEnabled":false,"rules":[]}],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"sparklineSettings":{"isVisible":false},"alignment":"start"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"42":{"type":"code","title":"Application (Apdex)","input":"import { rumUserSessionsClient } from \"@dynatrace-sdk/client-classic-environment-v1\";\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  // Calculate Chart Interval\n  const timeDiff = (endTime-startTime)/3600/1000/24;\n  var chartInterval = \"30m\"\n  if (timeDiff>.5)\n    var chartInterval = \"1h\"\n  if (timeDiff>1)\n    var chartInterval = \"1d\"\n  const query = 'SELECT DATETIME(endTime,  \"MM-dd HH:mm:ss\",\"'+chartInterval+'\") AS \"Date\", CONDITION(count(*), where userExperienceScore=\"SATISFIED\")  AS \"Satisfied\", CONDITION(count(*), where userExperienceScore=\"TOLERATED\")  AS \"Tolerated\", CONDITION(count(*), where userExperienceScore=\"FRUSTRATED\")  AS \"Frustrated\" from usersession WHERE usersession.starttime>='+startTime+' and usersession.endtime<='+endTime+' GROUP BY DATETIME(endTime,  \"MM-dd HH:mm:ss\",\"'+chartInterval+'\") limit 5000';\n  const response = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  const sampleCount = response.values.length;\n  return {\n    records: new Array(sampleCount).fill(null).map((_, index, array) => {\n      return {\n        Date: response.values[index][0],\n        'Apdex': (((response[\"values\"][index][1] + (response[\"values\"][index][2]/2))/(response[\"values\"][index][1] + response[\"values\"][index][2] + response[\"values\"][index][3])).toFixed(2))\n      };\n    }),\n    types: [\n      {\n        indexRange: [0, sampleCount],\n        mappings: {\n         Date: { type: 'timestamp' },\n          'Apdex': { type: 'double' }\n        },\n      },\n    ],\n  };\n}","visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{},"seriesOverrides":[],"legend":{"hidden":true},"categoricalBarChartSettings":{"categoryAxis":"Application","categoryAxisLabel":"Application","valueAxis":"Apdex","valueAxisLabel":"Apdex"}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}},"43":{"type":"code","title":"MTTR (Minutes)","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getProblemsList() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n    from: startTime,to: endTime, problemSelector: \"status(Closed)\"\n  });\n  const result = await response;\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n  const response = await getProblemsList();\n  const problems=response;\n  const types = [{\n      mappings: {\n        startTime: {type: 'timestamp'},\n        status: {type: 'string'},\n        displayId: {type: 'string'},\n        title: {type: 'string'},\n        impactLevel: {type: 'string'},\n        severityLevel: {type: 'string'},\n        affectedEntities: {type: 'string'},\n        impactedEntities: {type: 'string'},\n        rootCauseEntity: {type: 'string'},\n        duration: {type: 'double'},\n        \"event.id\": {type: 'string'},\n        endTime: {type: 'timestamp'}\n        },\n        indexRange: [\n        0,\n        problems.length\n      ]\n  }]\n  // Create a new empty data frame for the result\n  const dataFrame = {\n    records: [],\n    types: types\n  }\n  var mttr = 0;\n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      mttr = mttr + duration;\n      var pstatus = \"\";\n      if (problem.status == 'OPEN') {\n        pstatus = \"ðŸ”´ OPEN\";\n      } else {\n        pstatus = 'ðŸŸ¢ CLOSED';\n      }\n      var affectedEntities = expandArray(problem.affectedEntities);\n      var impactedEntities = expandArray(problem.impactedEntities);\n      var rootCause = \"\";\n      if (problem.rootCauseEntity == null) {\n        rootCause = \"\"\n      } else {\n        rootCause = problem.rootCauseEntity[\"name\"];\n      }\n       const record = {\n              startTime: problem.startTime,\n              status: pstatus,\n              displayId: problem.displayId,\n              title: problem.title,\n              impactLevel: problem.impactLevel,\n              severityLevel: problem.severityLevel,\n              affectedEntities: affectedEntities,\n              impactedEntities: impactedEntities,\n              rootCauseEntity: rootCause,\n              duration: duration,\n              \"event.id\": problem.problemId,\n              endTime: problem.endTime\n            }\n        dataFrame.records.push(record);\n    }\n//  return dataFrame;\n  return mttr/problems.length;\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[{"id":1,"field":"","title":"","isEnabled":false,"rules":[{"id":0,"color":{"Default":"var(--dt-colors-charts-categorical-color-09-default, #649438)"},"comparator":"â‰¥","label":"","value":0},{"id":1,"color":{"Default":"var(--dt-colors-charts-categorical-color-14-default, #d56b1a)"},"comparator":"â‰¥","label":"","value":30},{"id":2,"color":{"Default":"var(--dt-colors-charts-categorical-color-12-default, #cd3741)"},"comparator":"â‰¥","label":"","value":60}]}],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"49":{"type":"code","title":"Host ($HostKPI)","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\nexport default async function () {\n  const timeout = 60;\n  const query = `timeseries {metricKey}Array = avg(dt.host.{metricKey}.usage), from:\"{from}\", to:\"{to}\"\n| fieldsAdd {metricKey} = arrayAvg({metricKey}Array)`.replaceAll(\"{metricKey}\",$HostKPI).replace(\"{from}\",$dt_timeframe_from).replace(\"{to}\",$dt_timeframe_to);\n  const response = await queryExecutionClient.queryExecute({ body: { query, requestTimeoutMilliseconds: timeout * 1000, fetchTimeoutSeconds: timeout  } });\n\n  return response.result;\n}","visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{},"legend":{"hidden":true}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}},"51":{"type":"code","title":"Application (User Experience )","input":"import { rumUserSessionsClient } from \"@dynatrace-sdk/client-classic-environment-v1\";\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  // Calculate Chart Interval\n  const timeDiff = (endTime-startTime)/3600/1000/24;\n  var chartInterval = \"30m\"\n  if (timeDiff>.5)\n    var chartInterval = \"1h\"\n  if (timeDiff>1)\n    var chartInterval = \"1d\"\n  const query = 'SELECT DATETIME(endTime,  \"MM-dd HH:mm:ss\",\"'+chartInterval+'\") AS \"Date\", CONDITION(count(*), where userExperienceScore=\"SATISFIED\")  AS \"Satisfied\", CONDITION(count(*), where userExperienceScore=\"TOLERATED\")  AS \"Tolerated\", CONDITION(count(*), where userExperienceScore=\"FRUSTRATED\")  AS \"Frustrated\" from usersession WHERE usersession.starttime>='+startTime+' and usersession.endtime<='+endTime+' GROUP BY  DATETIME(endTime,  \"MM-dd HH:mm:ss\",\"'+chartInterval+'\") limit 5000';\n  const response = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  const sampleCount = response.values.length;\n  return {\n    records: new Array(sampleCount).fill(null).map((_, index, array) => {\n      return {\n        Date: response.values[index][0],\n        'Satisfied': (response.values[index][1]),\n        'Tolerated': response.values[index][2],\n        'Frustrated': response.values[index][3]\n      };\n    }),\n    types: [\n      {\n        indexRange: [0, sampleCount],\n        mappings: {\n         Date: { type: 'timestamp' },\n          'Satisfied': { type: 'double' },\n          'Tolerated': { type: 'double' },\n          'Frustrated': { type: 'double' }\n        },\n      },\n    ],\n  };\n}","visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{},"seriesOverrides":[{"seriesId":["Tolerated"],"override":{"color":"#FFFF00"}},{"seriesId":["Satisfied"],"override":{"color":"#008000"}},{"seriesId":["Frustrated"],"override":{"color":"#FF0000"}}],"legend":{"hidden":true},"categoricalBarChartSettings":{"categoryAxis":"Application","categoryAxisLabel":"Application","valueAxis":"Apdex","valueAxisLabel":"Apdex"}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}},"52":{"type":"code","title":"Application (KPI)","input":"import { rumUserSessionsClient } from '@dynatrace-sdk/client-classic-environment-v1';\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const query = 'SELECT avg('+$ApplicationKPI+') FROM useraction where starttime>='+startTime+' and endtime<='+endTime;\n  const result = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  return (result[\"values\"][0][0]).toFixed(2)/1000;\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"sparklineSettings":{"isVisible":false},"alignment":"start"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"53":{"type":"code","title":"Service ($ServiceKPI)","input":"/*\n* This function will run in the DYNATRACE JavaScript runtime.\n* For information visit https://dt-url.net/functions-help\n*/\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function () {\n\n  var metric_key = \"builtin:service.errors.total.rate\"\n  const data_type = \"double\"\n\n  if ($ServiceKPI==\"ResponseTime\") metric_key = \"builtin:service.response.time\";\n  \n  // Request Config\n  const config = {\n    metricSelector: buildQuery(metric_key),\n    resolution: \"10m\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  }\n\n  // Safety Precaution\n  if (config.metricSelector.length > 3500) {\n    return (\"Please select fewer services\")\n  }\n\n  // Metric Request\n  const metric_query = await metricsClient.query(config);\n\n  // var shortcut\n  const data = metric_query.result[0].data\n\n  // ??\n  data.forEach(obj => {\n    obj.values = obj.values.map(value => value === null ? 0 : value);\n  });\n\n  // ??\n  const mergedData: MergedData = {};\n  data.forEach((item) => {\n    const { dimensionMap, timestamps, values } = item;\n    const serviceName = dimensionMap[\"dt.entity.service.name\"];\n    const serviceId = dimensionMap[\"dt.entity.service\"];\n    timestamps.forEach((timestamp, index) => {\n      if (!mergedData[timestamp]) {\n        mergedData[timestamp] = {};\n      }\n      const serviceKey = `${serviceName} - ${serviceId}`;\n      mergedData[timestamp][serviceKey] = values[index];\n    });\n  });\n\n  // Merge service data\n  const mergedData2 = {};\n  const lib = Object.keys(mergedData);\n  lib.forEach(obj => {\n    const lib2 = Object.keys(mergedData[obj]);\n    let val = 0;\n    lib2.forEach(obj2 => {\n      val += mergedData[obj][obj2];\n    });\n    mergedData2[obj] = {\n      \"All Services\": val/lib2.length\n    };\n  });\n  \n  // Chart config + data + mapping\n  const mappings = {\n    timestamp: { type: 'timestamp' },\n  };\n  for (const item of data) {\n    mappings[\"All Services\"] = { type: data_type };    \n  }\n  const output = {\n    records: Object.entries(mergedData2).map(([timestamp, services]) => ({\n      timestamp: parseInt(timestamp),\n      ...services,\n    })),\n    types: [\n      {\n        indexRange: [0, data[0].timestamps.length - 1],\n        mappings,\n      },\n    ],\n  };   \n  return output;\n}\n\n// ?? Aggregate metrics - Not Used\nfunction combineData(input: any[]): any {\n  const records: any[] = [];\n  const mappings: any = {};\n\n  for (const item of input) {\n    const { dimensionMap, timestamps, values, dimensions } = item;\n\n    for (let i = 0; i < timestamps.length; i++) {\n      const timestamp = timestamps[i].toString();\n      const record: any = { timestamp };\n\n      for (let j = 0; j < dimensions.length; j++) {\n        const dimension = dimensions[j];\n        const value = values[i * dimensions.length + j];\n        record[dimension] = value || 0;\n\n        if (!mappings[dimension]) {\n          mappings[dimension] = { type: typeof value === 'number' ? 'double' : 'unknown' };\n        }\n      }\n\n      records.push(record);\n    }\n  }\n  const types: any[] = [{\n    indexRange: [0, records.length],\n    mappings\n  }];\n  console.log(\"records:\");\n  console.log(records);\n  return { records, types };\n}\n\n// Build Metric Query\nfunction buildQuery(metricKey: string): string {\n  //const filterString = `\"in(\"dt.entity.service\",entitySelector(\"type(service)\"))\"`\n  //return `${metricKey}:filter(${filterString}):splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n  return `${metricKey}:splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n}","visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{},"seriesOverrides":[],"legend":{"hidden":true}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}},"54":{"type":"code","title":"Log Error Rate","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\nexport default async function () {\n  \n  const timeout = 60;\n  const query = 'fetch logs, timeframe:\"'+$dt_timeframe_from+'/'+$dt_timeframe_to+'\" | summarize {logCount = count(), errorCount = countIf(status == \"ERROR\")} | fieldsAdd errorRate = (toDouble(errorCount) / toDouble(logCount)) * 100 | fields errorRate';\n  const query_response = await queryExecutionClient.queryExecute({ body: { query, requestTimeoutMilliseconds: timeout * 1000, fetchTimeoutSeconds: timeout  } });\n  const errorRate = parseInt(query_response.result[\"records\"][0][\"errorRate\"]);\n\n  return errorRate+\" %\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{},"lineWrapIds":[]}}},"55":{"type":"code","title":"Log Health","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\nexport default async function () {  \n  const timeout = 60;\n  const query = 'fetch logs, timeframe:\"'+$dt_timeframe_from+'/'+$dt_timeframe_to+'\" | summarize {logCount = count(), errorCount = countIf(status == \"ERROR\")} | fieldsAdd errorRate = (toDouble(errorCount) / toDouble(logCount)) * 100 | fields errorRate';\n  const query_response = await queryExecutionClient.queryExecute({ body: { query, requestTimeoutMilliseconds: timeout * 1000, fetchTimeoutSeconds: timeout  } });\n  const errorRate = parseInt(query_response.result[\"records\"][0][\"errorRate\"]);\n  if (errorRate>10) return \"ðŸ”´\";\n  if (errorRate>3) return \"ðŸŸ¡\";\n  return \"ðŸŸ¢\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{},"lineWrapIds":[]}}},"56":{"type":"markdown","title":"","content":"[**Help**](https://github.com/TechShady/Dynatrace-Dashboards-Gen3/blob/main/ReadMeOperationalHealth.md#user-guide)"},"57":{"type":"code","title":"Network Errors","input":"import { metricsClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nconst metric = \"builtin:host.net.nic.packets.errorsRx\";\nlet totalVal = 0;\n\nexport default async function main() {\n  try{\n    const config = {\n      acceptType: \"application/json; charset=utf-8\",\n      metricSelector: metric,\n      resolution: \"inf\",\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString()\n    }\n    const data = await metricsClient.query(config);\n    console.log(data.result[0].data);\n    (data.result[0].data).map(result => {\n      totalVal += result.values[0];\n    });\n    return (totalVal);\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"Network Errors","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"58":{"type":"data","title":"Problem Count","query":"fetch events, from:$dt_timeframe_from, to:$dt_timeframe_to\n| filter event.kind == \"DAVIS_PROBLEM\"\n| summarize {Problems = countDistinct(event.id), by: {`10m interval` = bin(timestamp, 10m)}}","davis":{"enabled":false},"visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"relative","groupingThresholdValue":0,"valueType":"relative"},"categoryOverrides":{},"seriesOverrides":[{"seriesId":["Problems"],"override":{"color":{"Default":"var(--dt-colors-charts-security-risk-level-critical-default, #8a0012)"}}}],"legend":{"hidden":true}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}}},"layouts":{"9":{"x":0,"y":0,"w":24,"h":1},"10":{"x":0,"y":3,"w":24,"h":1},"12":{"x":0,"y":1,"w":8,"h":2},"14":{"x":0,"y":10,"w":24,"h":1},"20":{"x":8,"y":1,"w":2,"h":2},"24":{"x":10,"y":1,"w":2,"h":2},"25":{"x":15,"y":4,"w":3,"h":3},"26":{"x":16,"y":1,"w":2,"h":2},"27":{"x":15,"y":7,"w":3,"h":3},"28":{"x":18,"y":1,"w":2,"h":2},"33":{"x":0,"y":17,"w":22,"h":1},"34":{"x":22,"y":1,"w":2,"h":2},"36":{"x":20,"y":1,"w":2,"h":2},"37":{"x":12,"y":1,"w":2,"h":2},"38":{"x":9,"y":7,"w":3,"h":3},"41":{"x":6,"y":4,"w":3,"h":3},"42":{"x":0,"y":4,"w":6,"h":3},"43":{"x":9,"y":4,"w":3,"h":3},"49":{"x":18,"y":4,"w":6,"h":3},"51":{"x":0,"y":7,"w":6,"h":3},"52":{"x":6,"y":7,"w":3,"h":3},"53":{"x":18,"y":7,"w":6,"h":3},"54":{"x":12,"y":4,"w":3,"h":3},"55":{"x":14,"y":1,"w":2,"h":2},"56":{"x":22,"y":17,"w":2,"h":1},"57":{"x":12,"y":7,"w":3,"h":3},"58":{"x":0,"y":11,"w":24,"h":6}}}