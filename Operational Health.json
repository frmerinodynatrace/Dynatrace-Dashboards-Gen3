{"version":11,"variables":[{"key":"HostKPI","type":"csv","input":"cpu,memory","multiple":false},{"key":"ApplicationKPI","type":"csv","input":"Duration,VisuallyCompleteTime,SpeedIndex,LoadEventEnd,FirstInputDelay,CumulativeLayoutShift,LargestContentfulPaint,CdnBusyTime,CdnResources,DocumentInteractiveTime,DomCompleteTime,DomContentLoadedTime,FirstPartyBusyTime,FirstPartyResources,FrontendTime,LoadEventStart,NavigationStart,NetworkTime,RequestStart,ResponseEnd,ResponseStart,ServerTime,ThirdPartyBusyTime,ThirdPartyResources","multiple":false},{"key":"ServiceKPI","type":"csv","input":"ErrorRate,ResponseTime","multiple":false}],"tiles":{"9":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"10":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"12":{"type":"markdown","title":"","content":"![](data:image/webp;base64,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)"},"14":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"20":{"type":"code","title":"Overall Health","input":"const From=$dt_timeframe_from;\nconst To=$dt_timeframe_to;\nvar healthCount=0;\nconst metric = \"builtin:host.net.nic.packets.errorsRx\";\nlet totalVal = 0;\nimport { rumUserSessionsClient } from '@dynatrace-sdk/client-classic-environment-v1';\nimport { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\nimport { metricsClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\nimport { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\nimport { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\nasync function getProblemsList() {\n  \n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n    from: startTime,to: endTime, problemSelector: \"status(Closed)\"\n  });\n  const result = await response;\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n// Start Logs\n  const timeout = 60;\n  var query = 'fetch logs, timeframe:\"'+$dt_timeframe_from+'/'+$dt_timeframe_to+'\" | summarize {logCount = count(), errorCount = countIf(status == \"ERROR\")} | fieldsAdd errorRate = (toDouble(errorCount) / toDouble(logCount)) * 100 | fields errorRate';\n  const query_response = await queryExecutionClient.queryExecute({ body: { query, requestTimeoutMilliseconds: timeout * 1000, fetchTimeoutSeconds: timeout  } });\n  const errorRate = parseInt(query_response.result[\"records\"][0][\"errorRate\"]);\n  if (errorRate>10) healthCount=healthCount+2;\n  if (errorRate>3) healthCount=healthCount+1;\n// End Logs\n \n// Start Security\nasync function pollQuery(requestToken, resolve) {\n\n  const poll = await queryExecutionClient.queryPoll({requestToken, requestTimeoutMilliseconds: 3000});\n  if(poll.result) {\n      resolve(poll.result);\n  } else {\n      pollQuery(requestToken, resolve);\n  }\n}\nfunction runQuery (query) {\n  return new Promise(async (resolve, reject) => {\n\n      const queryExecution = await queryExecutionClient.queryExecute({body: { query }});\n      if(queryExecution.result) {\n          resolve(queryExecution.result);\n      } else {\n          pollQuery(queryExecution.requestToken, resolve)\n      }\n\n  });\n}\n\n const commonFilterQueryPart =\n `fetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n// filter only the latest snapshot data\n| fieldsAdd matcher=\"match\"\n| lookup [\nfetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n| fields \nmaxTimestamp=timestamp,\nmatcher=\"match\"\n| limit 1\n], sourceField:matcher, lookupField:matcher\n| filter timestamp==lookup.maxTimestamp\n//end of filtering for the latest snapshot`;\n \n const vulnBySeverityQueryString = `${commonFilterQueryPart}\n | summarize \n   Muted=takeFirst(vulnerability.mute.status==\"MUTED\"), \n   vulnerability.risk.level=takeFirst(vulnerability.risk.level), \n   by: {vulnerability.display_id, timestamp} \n | summarize \n C=countIf(vulnerability.risk.level==\"CRITICAL\" AND Muted==FALSE), \n H=countIf(vulnerability.risk.level==\"HIGH\" AND Muted==FALSE), \n M=countIf(vulnerability.risk.level==\"MEDIUM\" AND Muted==FALSE), \n L=countIf(vulnerability.risk.level==\"LOW\" AND Muted==FALSE), \n by: {timestamp} \n | summarize  \n C=takeLast(C), \n H=takeLast(H), \n M=takeLast(M), \n L=takeLast(L)`;\n \n const avgRiskScoreQueryString = `${commonFilterQueryPart}\n | summarize \n  Risk = takeFirst(vulnerability.risk.level), \n  Muted=takeFirst(vulnerability.mute.status), \n  RiskScore=takeFirst(vulnerability.risk.score), \n  by: {vulnerability.display_id, timestamp} \n | filterOut Muted == \"MUTED\"\n | summarize \n  average=avg(RiskScore), \n  by: {risk=Risk, timestamp} \n | summarize average=takeLast(average), \n by: {risk}`;\n \n \n  // Get the counts per risk level using DQL\n  console.log(vulnBySeverityQueryString);\n  const vulnBySeverityQueryResult = await runQuery(vulnBySeverityQueryString); \n  \n  if (vulnBySeverityQueryResult.records == null || vulnBySeverityQueryResult.records.length==0){\n    return \"No Data\";\n  }\n  const vulnBySeverity=vulnBySeverityQueryResult.records[0];\n  \n    // Define data set: Number of problems per criticality level\n  \n    // Get the avg score per risk level using DQL\n  const avgRiskScoreQueryResult = await runQuery(avgRiskScoreQueryString);\n  \n  const avgRiskScore=avgRiskScoreQueryResult.records.reduce((obj,record)=>{\n      \n    if(record == null ||  obj == null || record.average == null) return;\n    if(record.risk==\"CRITICAL\"){\n      obj.C=record.average;\n    }\n    if(record.risk==\"HIGH\"){\n      obj.H=record.average;\n    }\n    if(record.risk==\"MEDIUM\"){\n      obj.M=record.average;\n    }\n    if(record.risk==\"LOW\"){\n      obj.L=record.average;\n    }\n    return obj;\n  },{\"C\":0,\"H\":0,\"M\":0,\"L\":0});\n\n  // Define weights of the criticality level. Higher weight means that the contribution in the highest criticality level is higher.\n  const weights = {\n    \"C\": 60,\n    \"H\": 20,\n    \"M\": 5,\n    \"L\": 1,\n  };\n \n  // Define ranges for the criticality levels\n  const scoreRanges = {\n      \"C\": [9, 10],\n      \"H\": [7, 9],\n      \"M\": [4, 7],\n      \"L\": [0.5, 4],\n    };\n \n \n  // Normalize the average risk score of each severity against the score range of that severity (output between 0 and 1).\n  const normalizedAvgSeverities={}\n  for(const[severity, avg] of Object.entries(avgRiskScore)){\n    const minScore=scoreRanges[severity][0];\n    const maxScore=scoreRanges[severity][1];\n    const scoreRange=maxScore-minScore;\n    normalizedAvgSeverities[severity]=(avgRiskScore[severity]-minScore)/scoreRange;\n  }\n    // Define logistic function and scale to make sense of the amount of problems in a criticality level (output is always between 0 and 1)\n    const scale=10\n    function logistic(x) {\n      return Math.tanh(x/scale)\n    }\n  \n    const severities = Object.keys(vulnBySeverity);\n   \n    let score=0;\n    let minScore=0;\n    let maxScore=0;\n   \n    const unrelevantSeverities=[];\n   \n    // Calculate min/max and the distance between min and max (the final score range) in the highest available criticality level\n    for (const severity of severities) {\n      if (vulnBySeverity[severity] >= 1) {\n        minScore=scoreRanges[severity][0];\n        maxScore=scoreRanges[severity][1];\n        break;\n      }else{\n        // Remove all severities that are above the maximum range to have a better result for lower scores\n        unrelevantSeverities.push(severity); \n      }\n    }\n    const scoreRange=maxScore-minScore;\n   \n    const relevantWeights=Object.fromEntries(Object.entries(weights).filter(([severity,weight]) => !unrelevantSeverities.includes(severity)));\n    const relevantSeverities=severities.filter((severity,weight) => !unrelevantSeverities.includes(severity));\n   \n    \n    // Convert weights into percentage based ratios\n    const weightRatios={};\n    let totalWeight = Object.values(relevantWeights).reduce((acc, number) => acc + number, 0);\n    for(const[severity, weight] of Object.entries(relevantWeights)){\n      weightRatios[severity]=weight/totalWeight;\n    }\n   \n    // Increase the min score of the highest criticality level by the score contribution of each criticality level (based on weight and count)\n    let addedScore=0;\n    for(const severity of relevantSeverities){\n      const maxAddedScore=weightRatios[severity]*scoreRange;\n      const scoreContribution=maxAddedScore*logistic(vulnBySeverity[severity])*normalizedAvgSeverities[severity];\n      addedScore+=scoreContribution\n    }\n   \n    // Calculate final score\n    const finalScore= (minScore + addedScore)*10;\n    let scoreStr=finalScore.toPrecision(2);\n    if (scoreStr>89)\n      healthCount=healthCount+2;\n    if (scoreStr>70)\n      healthCount=healthCount+1;\n// End Security\n// Start Service\n  try{\n    const healthyS = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const badS = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    if (((healthyS.totalCount *100) / (healthyS.totalCount + badS.totalCount)).toFixed(2)<100)\n      healthCount=healthCount+2;\n  }\n  catch(e){\n    console.log(e);\n  }\n// End Service\n// Start Host\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    if (((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(2)<100)\n      healthCount=healthCount+2;\n  }\n  catch(e){\n    console.log(e);\n  }\n// End Host\n// Start Application\n  const startTime2 = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime2 = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  var query = 'SELECT CONDITION (count(*),WHERE userexperiencescore=\"SATISFIED\"), CONDITION (count(*),WHERE userexperiencescore=\"TOLERATED\"), CONDITION (count(*),WHERE userexperiencescore=\"FRUSTRATED\") FROM usersession where starttime>='+startTime2+' and endtime<='+endTime2;\n  const result = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime2, endTimestamp: endTime2});\n  if (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2]))*100<80)\n    healthCount=healthCount+2;\n  if (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2]))*100<92)\n    healthCount=healthCount+1;\n// End Application\n// Start Network\n  try{\n    const config = {\n      acceptType: \"application/json; charset=utf-8\",\n      metricSelector: metric,\n      resolution: \"inf\",\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString()\n    }\n    const data = await metricsClient.query(config);\n    console.log(data.result[0].data);\n    (data.result[0].data).map(result => {\n      totalVal += result.values[0];\n    });\n    if (totalVal>0) healthCount=healthCount+2;\n  }\n  catch(e){\n    console.log(e);\n  }\n// End Network\n// Start Davis \n  const response = await getProblemsList();\n  const problems=response;\n  const types = [{\n      mappings: {\n        startTime: {type: 'timestamp'},\n        status: {type: 'string'},\n        displayId: {type: 'string'},\n        title: {type: 'string'},\n        impactLevel: {type: 'string'},\n        severityLevel: {type: 'string'},\n        affectedEntities: {type: 'string'},\n        impactedEntities: {type: 'string'},\n        rootCauseEntity: {type: 'string'},\n        duration: {type: 'double'},\n        \"event.id\": {type: 'string'},\n        endTime: {type: 'timestamp'}\n        },\n        indexRange: [\n        0,\n        problems.length\n      ]\n  }]\n  // Create a new empty data frame for the result\n  const dataFrame = {\n    records: [],\n    types: types\n  }\n  var mttr = 0;\n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      mttr = mttr + duration;\n      var pstatus = \"\";\n      if (problem.status == 'OPEN') {\n        pstatus = \"游댮 OPEN\";\n      } else {\n        pstatus = '游릭 CLOSED';\n      }\n      var affectedEntities = expandArray(problem.affectedEntities);\n      var impactedEntities = expandArray(problem.impactedEntities);\n      var rootCause = \"\";\n      if (problem.rootCauseEntity == null) {\n        rootCause = \"\"\n      } else {\n        rootCause = problem.rootCauseEntity[\"name\"];\n      }\n       const record = {\n              startTime: problem.startTime,\n              status: pstatus,\n              displayId: problem.displayId,\n              title: problem.title,\n              impactLevel: problem.impactLevel,\n              severityLevel: problem.severityLevel,\n              affectedEntities: affectedEntities,\n              impactedEntities: impactedEntities,\n              rootCauseEntity: rootCause,\n              duration: duration,\n              \"event.id\": problem.problemId,\n              endTime: problem.endTime\n            }\n        dataFrame.records.push(record);\n    }\n//  return dataFrame;\n  if ((mttr/problems.length)>60) healthCount=healthCount+2;\n  if ((mttr/problems.length)>30) healthCount=healthCount+1;\n// End Davis \n\n  if (healthCount>1)\n    return \"游댮\";\n  if (healthCount>0)\n    return \"游리\";\n  return \"游릭\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"24":{"type":"code","title":"Application Health","input":"import { rumUserSessionsClient } from '@dynatrace-sdk/client-classic-environment-v1';\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const query = 'SELECT CONDITION (count(*),WHERE userexperiencescore=\"SATISFIED\"), CONDITION (count(*),WHERE userexperiencescore=\"TOLERATED\"), CONDITION (count(*),WHERE userexperiencescore=\"FRUSTRATED\") FROM usersession where starttime>='+startTime+' and endtime<='+endTime;\n  const result = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  if (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2]))*100<80)\n    return \"游댮\";\n  if (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2]))*100<92)\n    return \"游리\";\n  return \"游릭\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"sparklineSettings":{"isVisible":false},"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"25":{"type":"code","title":"Host (% Healthy)","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function fetchMetricResults() {\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    return ((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(0) + \" %\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"26":{"type":"code","title":"Host Health","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function fetchMetricResults() {\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(HOST),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    if (((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(2)<100)\n      return \"游댮\";\n    else \n      return \"游릭\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"27":{"type":"code","title":"Service (% Healthy)","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function fetchMetricResults() {\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    return ((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(0) + \" %\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"28":{"type":"code","title":"Service Health","input":"import { monitoredEntitiesClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function fetchMetricResults() {\n  try{\n    const healthy = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"HEALTHY\\\")\",\n      pageSize: 1\n    });\n    const bad = await monitoredEntitiesClient.getEntities({\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString(),\n      entitySelector: \"type(SERVICE),healthState(\\\"UNHEALTHY\\\")\",\n      pageSize: 1\n    });\n    if (((healthy.totalCount *100) / (healthy.totalCount + bad.totalCount)).toFixed(2)<100)\n      return \"游댮\";\n    else \n      return \"游릭\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"32":{"type":"data","title":"Problem Count","query":"fetch events, from:$dt_timeframe_from, to:$dt_timeframe_to\n| filter event.kind == \"DAVIS_PROBLEM\"\n| summarize {Problems = countDistinct(event.id), by: {`10m interval` = bin(timestamp, 10m)}}","visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{},"colorPalette":"vulnerability-risk-level","legend":{"hidden":true}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}},"33":{"type":"markdown","title":"","content":"![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABy8AAAAMCAYAAADbJPG3AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAACdSURBVHhe7dtBFcAgDETBUBtFA6KrDhf0gofsYeay8fBfRn37FAAAAAAAAECz5y4AAAAAAABAK/ESAAAAAAAAiCBeAgAAAAAAABHESwAAAAAAACCCeAkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEGG8c517AwAAAAAAALTxeQkAAAAAAABEEC8BAAAAAACACOIlAAAAAAAAEKDqB2IIBAQ2TEouAAAAAElFTkSuQmCC)"},"34":{"type":"code","title":"Davis Health","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getProblemsList() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n    from: startTime,to: endTime, problemSelector: \"status(Closed)\"\n  });\n  const result = await response;\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n  const response = await getProblemsList();\n  const problems=response;\n  const types = [{\n      mappings: {\n        startTime: {type: 'timestamp'},\n        status: {type: 'string'},\n        displayId: {type: 'string'},\n        title: {type: 'string'},\n        impactLevel: {type: 'string'},\n        severityLevel: {type: 'string'},\n        affectedEntities: {type: 'string'},\n        impactedEntities: {type: 'string'},\n        rootCauseEntity: {type: 'string'},\n        duration: {type: 'double'},\n        \"event.id\": {type: 'string'},\n        endTime: {type: 'timestamp'}\n        },\n        indexRange: [\n        0,\n        problems.length\n      ]\n  }]\n  // Create a new empty data frame for the result\n  const dataFrame = {\n    records: [],\n    types: types\n  }\n  var mttr = 0;\n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      mttr = mttr + duration;\n      var pstatus = \"\";\n      if (problem.status == 'OPEN') {\n        pstatus = \"游댮 OPEN\";\n      } else {\n        pstatus = '游릭 CLOSED';\n      }\n      var affectedEntities = expandArray(problem.affectedEntities);\n      var impactedEntities = expandArray(problem.impactedEntities);\n      var rootCause = \"\";\n      if (problem.rootCauseEntity == null) {\n        rootCause = \"\"\n      } else {\n        rootCause = problem.rootCauseEntity[\"name\"];\n      }\n       const record = {\n              startTime: problem.startTime,\n              status: pstatus,\n              displayId: problem.displayId,\n              title: problem.title,\n              impactLevel: problem.impactLevel,\n              severityLevel: problem.severityLevel,\n              affectedEntities: affectedEntities,\n              impactedEntities: impactedEntities,\n              rootCauseEntity: rootCause,\n              duration: duration,\n              \"event.id\": problem.problemId,\n              endTime: problem.endTime\n            }\n        dataFrame.records.push(record);\n    }\n//  return dataFrame;\n  if ((mttr/problems.length)>60) return \"游댮\";\n  if ((mttr/problems.length)>30) return \"游리\";\n  return \"游릭\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"36":{"type":"code","title":"Network Health","input":"import { metricsClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nconst metric = \"builtin:host.net.nic.packets.errorsRx\";\nlet totalVal = 0;\n\nexport default async function main() {\n  try{\n    const config = {\n      acceptType: \"application/json; charset=utf-8\",\n      metricSelector: metric,\n      resolution: \"inf\",\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString()\n    }\n    const data = await metricsClient.query(config);\n    console.log(data.result[0].data);\n    (data.result[0].data).map(result => {\n      totalVal += result.values[0];\n    });\n    if (totalVal>0)\n      return \"游댮\";\n    return \"游릭\";\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"37":{"type":"code","title":"Security Health","input":"const From=$dt_timeframe_from;\nconst To=$dt_timeframe_to;\nimport { queryExecutionClient } from '@dynatrace-sdk/client-query';\nexport default async function () {\nasync function pollQuery(requestToken, resolve) {\n\n  const poll = await queryExecutionClient.queryPoll({requestToken, requestTimeoutMilliseconds: 3000});\n  if(poll.result) {\n      resolve(poll.result);\n  } else {\n      pollQuery(requestToken, resolve);\n  }\n}\nfunction runQuery (query) {\n  return new Promise(async (resolve, reject) => {\n\n      const queryExecution = await queryExecutionClient.queryExecute({body: { query }});\n      if(queryExecution.result) {\n          resolve(queryExecution.result);\n      } else {\n          pollQuery(queryExecution.requestToken, resolve)\n      }\n\n  });\n}\n\n const commonFilterQueryPart =\n `fetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n// filter only the latest snapshot data\n| fieldsAdd matcher=\"match\"\n| lookup [\nfetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n| fields \nmaxTimestamp=timestamp,\nmatcher=\"match\"\n| limit 1\n], sourceField:matcher, lookupField:matcher\n| filter timestamp==lookup.maxTimestamp\n//end of filtering for the latest snapshot`;\n \n const vulnBySeverityQueryString = `${commonFilterQueryPart}\n | summarize \n   Muted=takeFirst(vulnerability.mute.status==\"MUTED\"), \n   vulnerability.risk.level=takeFirst(vulnerability.risk.level), \n   by: {vulnerability.display_id, timestamp} \n | summarize \n C=countIf(vulnerability.risk.level==\"CRITICAL\" AND Muted==FALSE), \n H=countIf(vulnerability.risk.level==\"HIGH\" AND Muted==FALSE), \n M=countIf(vulnerability.risk.level==\"MEDIUM\" AND Muted==FALSE), \n L=countIf(vulnerability.risk.level==\"LOW\" AND Muted==FALSE), \n by: {timestamp} \n | summarize  \n C=takeLast(C), \n H=takeLast(H), \n M=takeLast(M), \n L=takeLast(L)`;\n \n const avgRiskScoreQueryString = `${commonFilterQueryPart}\n | summarize \n  Risk = takeFirst(vulnerability.risk.level), \n  Muted=takeFirst(vulnerability.mute.status), \n  RiskScore=takeFirst(vulnerability.risk.score), \n  by: {vulnerability.display_id, timestamp} \n | filterOut Muted == \"MUTED\"\n | summarize \n  average=avg(RiskScore), \n  by: {risk=Risk, timestamp} \n | summarize average=takeLast(average), \n by: {risk}`;\n \n \n  // Get the counts per risk level using DQL\n  console.log(vulnBySeverityQueryString);\n  const vulnBySeverityQueryResult = await runQuery(vulnBySeverityQueryString); \n  \n  if (vulnBySeverityQueryResult.records == null || vulnBySeverityQueryResult.records.length==0){\n    return \"No Data\";\n  }\n  const vulnBySeverity=vulnBySeverityQueryResult.records[0];\n  \n    // Define data set: Number of problems per criticality level\n  \n    // Get the avg score per risk level using DQL\n  const avgRiskScoreQueryResult = await runQuery(avgRiskScoreQueryString);\n  \n  const avgRiskScore=avgRiskScoreQueryResult.records.reduce((obj,record)=>{\n      \n    if(record == null ||  obj == null || record.average == null) return;\n    if(record.risk==\"CRITICAL\"){\n      obj.C=record.average;\n    }\n    if(record.risk==\"HIGH\"){\n      obj.H=record.average;\n    }\n    if(record.risk==\"MEDIUM\"){\n      obj.M=record.average;\n    }\n    if(record.risk==\"LOW\"){\n      obj.L=record.average;\n    }\n    return obj;\n  },{\"C\":0,\"H\":0,\"M\":0,\"L\":0});\n\n  // Define weights of the criticality level. Higher weight means that the contribution in the highest criticality level is higher.\n  const weights = {\n    \"C\": 60,\n    \"H\": 20,\n    \"M\": 5,\n    \"L\": 1,\n  };\n \n  // Define ranges for the criticality levels\n  const scoreRanges = {\n      \"C\": [9, 10],\n      \"H\": [7, 9],\n      \"M\": [4, 7],\n      \"L\": [0.5, 4],\n    };\n \n \n  // Normalize the average risk score of each severity against the score range of that severity (output between 0 and 1).\n  const normalizedAvgSeverities={}\n  for(const[severity, avg] of Object.entries(avgRiskScore)){\n    const minScore=scoreRanges[severity][0];\n    const maxScore=scoreRanges[severity][1];\n    const scoreRange=maxScore-minScore;\n    normalizedAvgSeverities[severity]=(avgRiskScore[severity]-minScore)/scoreRange;\n  }\n    // Define logistic function and scale to make sense of the amount of problems in a criticality level (output is always between 0 and 1)\n    const scale=10\n    function logistic(x) {\n      return Math.tanh(x/scale)\n    }\n  \n    const severities = Object.keys(vulnBySeverity);\n   \n    let score=0;\n    let minScore=0;\n    let maxScore=0;\n   \n    const unrelevantSeverities=[];\n   \n    // Calculate min/max and the distance between min and max (the final score range) in the highest available criticality level\n    for (const severity of severities) {\n      if (vulnBySeverity[severity] >= 1) {\n        minScore=scoreRanges[severity][0];\n        maxScore=scoreRanges[severity][1];\n        break;\n      }else{\n        // Remove all severities that are above the maximum range to have a better result for lower scores\n        unrelevantSeverities.push(severity); \n      }\n    }\n    const scoreRange=maxScore-minScore;\n   \n    const relevantWeights=Object.fromEntries(Object.entries(weights).filter(([severity,weight]) => !unrelevantSeverities.includes(severity)));\n    const relevantSeverities=severities.filter((severity,weight) => !unrelevantSeverities.includes(severity));\n   \n    \n    // Convert weights into percentage based ratios\n    const weightRatios={};\n    let totalWeight = Object.values(relevantWeights).reduce((acc, number) => acc + number, 0);\n    for(const[severity, weight] of Object.entries(relevantWeights)){\n      weightRatios[severity]=weight/totalWeight;\n    }\n   \n    // Increase the min score of the highest criticality level by the score contribution of each criticality level (based on weight and count)\n    let addedScore=0;\n    for(const severity of relevantSeverities){\n      const maxAddedScore=weightRatios[severity]*scoreRange;\n      const scoreContribution=maxAddedScore*logistic(vulnBySeverity[severity])*normalizedAvgSeverities[severity];\n      addedScore+=scoreContribution\n    }\n   \n    // Calculate final score\n    const finalScore= (minScore + addedScore)*10;\n    let scoreStr=finalScore.toPrecision(2);\n    if (scoreStr>89)\n      return \"游댮\";\n    if (scoreStr>70)\n      return \"游리\";\n    return \"游릭\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"38":{"type":"code","title":"Security Score","input":"const From=$dt_timeframe_from;\nconst To=$dt_timeframe_to;\nimport { queryExecutionClient } from '@dynatrace-sdk/client-query';\nexport default async function () {\nasync function pollQuery(requestToken, resolve) {\n\n  const poll = await queryExecutionClient.queryPoll({requestToken, requestTimeoutMilliseconds: 3000});\n  if(poll.result) {\n      resolve(poll.result);\n  } else {\n      pollQuery(requestToken, resolve);\n  }\n}\nfunction runQuery (query) {\n  return new Promise(async (resolve, reject) => {\n\n      const queryExecution = await queryExecutionClient.queryExecute({body: { query }});\n      if(queryExecution.result) {\n          resolve(queryExecution.result);\n      } else {\n          pollQuery(queryExecution.requestToken, resolve)\n      }\n\n  });\n}\n\n const commonFilterQueryPart =\n `fetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n// filter only the latest snapshot data\n| fieldsAdd matcher=\"match\"\n| lookup [\nfetch events, from:toTimestamp(\"${From}\"), to:toTimestamp(\"${To}\")\n| filter event.provider==\"Dynatrace\"\n| filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n| filter event.level==\"ENTITY\"\n| filter vulnerability.risk.level==\"CRITICAL\"\n| fields \nmaxTimestamp=timestamp,\nmatcher=\"match\"\n| limit 1\n], sourceField:matcher, lookupField:matcher\n| filter timestamp==lookup.maxTimestamp\n//end of filtering for the latest snapshot`;\n \n const vulnBySeverityQueryString = `${commonFilterQueryPart}\n | summarize \n   Muted=takeFirst(vulnerability.mute.status==\"MUTED\"), \n   vulnerability.risk.level=takeFirst(vulnerability.risk.level), \n   by: {vulnerability.display_id, timestamp} \n | summarize \n C=countIf(vulnerability.risk.level==\"CRITICAL\" AND Muted==FALSE), \n H=countIf(vulnerability.risk.level==\"HIGH\" AND Muted==FALSE), \n M=countIf(vulnerability.risk.level==\"MEDIUM\" AND Muted==FALSE), \n L=countIf(vulnerability.risk.level==\"LOW\" AND Muted==FALSE), \n by: {timestamp} \n | summarize  \n C=takeLast(C), \n H=takeLast(H), \n M=takeLast(M), \n L=takeLast(L)`;\n \n const avgRiskScoreQueryString = `${commonFilterQueryPart}\n | summarize \n  Risk = takeFirst(vulnerability.risk.level), \n  Muted=takeFirst(vulnerability.mute.status), \n  RiskScore=takeFirst(vulnerability.risk.score), \n  by: {vulnerability.display_id, timestamp} \n | filterOut Muted == \"MUTED\"\n | summarize \n  average=avg(RiskScore), \n  by: {risk=Risk, timestamp} \n | summarize average=takeLast(average), \n by: {risk}`;\n \n \n  // Get the counts per risk level using DQL\n  console.log(vulnBySeverityQueryString);\n  const vulnBySeverityQueryResult = await runQuery(vulnBySeverityQueryString); \n  \n  if (vulnBySeverityQueryResult.records == null || vulnBySeverityQueryResult.records.length==0){\n    return \"No Data\";\n  }\n  const vulnBySeverity=vulnBySeverityQueryResult.records[0];\n  \n    // Define data set: Number of problems per criticality level\n  \n    // Get the avg score per risk level using DQL\n  const avgRiskScoreQueryResult = await runQuery(avgRiskScoreQueryString);\n  \n  const avgRiskScore=avgRiskScoreQueryResult.records.reduce((obj,record)=>{\n      \n    if(record == null ||  obj == null || record.average == null) return;\n    if(record.risk==\"CRITICAL\"){\n      obj.C=record.average;\n    }\n    if(record.risk==\"HIGH\"){\n      obj.H=record.average;\n    }\n    if(record.risk==\"MEDIUM\"){\n      obj.M=record.average;\n    }\n    if(record.risk==\"LOW\"){\n      obj.L=record.average;\n    }\n    return obj;\n  },{\"C\":0,\"H\":0,\"M\":0,\"L\":0});\n\n  // Define weights of the criticality level. Higher weight means that the contribution in the highest criticality level is higher.\n  const weights = {\n    \"C\": 60,\n    \"H\": 20,\n    \"M\": 5,\n    \"L\": 1,\n  };\n \n  // Define ranges for the criticality levels\n  const scoreRanges = {\n      \"C\": [9, 10],\n      \"H\": [7, 9],\n      \"M\": [4, 7],\n      \"L\": [0.5, 4],\n    };\n \n \n  // Normalize the average risk score of each severity against the score range of that severity (output between 0 and 1).\n  const normalizedAvgSeverities={}\n  for(const[severity, avg] of Object.entries(avgRiskScore)){\n    const minScore=scoreRanges[severity][0];\n    const maxScore=scoreRanges[severity][1];\n    const scoreRange=maxScore-minScore;\n    normalizedAvgSeverities[severity]=(avgRiskScore[severity]-minScore)/scoreRange;\n  }\n    // Define logistic function and scale to make sense of the amount of problems in a criticality level (output is always between 0 and 1)\n    const scale=10\n    function logistic(x) {\n      return Math.tanh(x/scale)\n    }\n  \n    const severities = Object.keys(vulnBySeverity);\n   \n    let score=0;\n    let minScore=0;\n    let maxScore=0;\n   \n    const unrelevantSeverities=[];\n   \n    // Calculate min/max and the distance between min and max (the final score range) in the highest available criticality level\n    for (const severity of severities) {\n      if (vulnBySeverity[severity] >= 1) {\n        minScore=scoreRanges[severity][0];\n        maxScore=scoreRanges[severity][1];\n        break;\n      }else{\n        // Remove all severities that are above the maximum range to have a better result for lower scores\n        unrelevantSeverities.push(severity); \n      }\n    }\n    const scoreRange=maxScore-minScore;\n   \n    const relevantWeights=Object.fromEntries(Object.entries(weights).filter(([severity,weight]) => !unrelevantSeverities.includes(severity)));\n    const relevantSeverities=severities.filter((severity,weight) => !unrelevantSeverities.includes(severity));\n   \n    \n    // Convert weights into percentage based ratios\n    const weightRatios={};\n    let totalWeight = Object.values(relevantWeights).reduce((acc, number) => acc + number, 0);\n    for(const[severity, weight] of Object.entries(relevantWeights)){\n      weightRatios[severity]=weight/totalWeight;\n    }\n   \n    // Increase the min score of the highest criticality level by the score contribution of each criticality level (based on weight and count)\n    let addedScore=0;\n    for(const severity of relevantSeverities){\n      const maxAddedScore=weightRatios[severity]*scoreRange;\n      const scoreContribution=maxAddedScore*logistic(vulnBySeverity[severity])*normalizedAvgSeverities[severity];\n      addedScore+=scoreContribution\n    }\n   \n    // Calculate final score\n    const finalScore= (minScore + addedScore)*10;\n    let scoreStr=finalScore.toPrecision(2);\n    return scoreStr;\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"39":{"type":"code","title":"Network Errors","input":"import { metricsClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nconst metric = \"builtin:host.net.nic.packets.errorsRx\";\nlet totalVal = 0;\n\nexport default async function main() {\n  try{\n    const config = {\n      acceptType: \"application/json; charset=utf-8\",\n      metricSelector: metric,\n      resolution: \"inf\",\n      from: Date.parse($dt_timeframe_from).toString(),\n      to: Date.parse($dt_timeframe_to).toString()\n    }\n    const data = await metricsClient.query(config);\n    console.log(data.result[0].data);\n    (data.result[0].data).map(result => {\n      totalVal += result.values[0];\n    });\n    return (totalVal);\n  }\n  catch(e){\n    console.log(e);\n  }\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"41":{"type":"code","title":"Application (Apdex)","input":"import { rumUserSessionsClient } from '@dynatrace-sdk/client-classic-environment-v1';\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const query = 'SELECT CONDITION (count(*),WHERE userexperiencescore=\"SATISFIED\"), CONDITION (count(*),WHERE userexperiencescore=\"TOLERATED\"), CONDITION (count(*),WHERE userexperiencescore=\"FRUSTRATED\") FROM usersession where starttime>='+startTime+' and endtime<='+endTime;\n  const result = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  return (((result[\"values\"][0][0] + (result[\"values\"][0][1]/2))/(result[\"values\"][0][0] + result[\"values\"][0][1] + result[\"values\"][0][2])).toFixed(2));\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"sparklineSettings":{"isVisible":false},"alignment":"start"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"42":{"type":"code","title":"Application (Apdex)","input":"import { rumUserSessionsClient } from \"@dynatrace-sdk/client-classic-environment-v1\";\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  // Calculate Chart Interval\n  const timeDiff = (endTime-startTime)/3600/1000/24;\n  var chartInterval = \"30m\"\n  if (timeDiff>.5)\n    var chartInterval = \"1h\"\n  if (timeDiff>1)\n    var chartInterval = \"1d\"\n  const query = 'SELECT DATETIME(endTime,  \"MM-dd HH:mm:ss\",\"'+chartInterval+'\") AS \"Date\", CONDITION(count(*), where userExperienceScore=\"SATISFIED\")  AS \"Satisfied\", CONDITION(count(*), where userExperienceScore=\"TOLERATED\")  AS \"Tolerated\", CONDITION(count(*), where userExperienceScore=\"FRUSTRATED\")  AS \"Frustrated\" from usersession WHERE usersession.starttime>='+startTime+' and usersession.endtime<='+endTime+' GROUP BY DATETIME(endTime,  \"MM-dd HH:mm:ss\",\"'+chartInterval+'\") limit 5000';\n  const response = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  const sampleCount = response.values.length;\n  return {\n    records: new Array(sampleCount).fill(null).map((_, index, array) => {\n      return {\n        Date: response.values[index][0],\n        'Apdex': (((response[\"values\"][index][1] + (response[\"values\"][index][2]/2))/(response[\"values\"][index][1] + response[\"values\"][index][2] + response[\"values\"][index][3])).toFixed(2))\n      };\n    }),\n    types: [\n      {\n        indexRange: [0, sampleCount],\n        mappings: {\n         Date: { type: 'timestamp' },\n          'Apdex': { type: 'double' }\n        },\n      },\n    ],\n  };\n}","visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{},"seriesOverrides":[],"legend":{"hidden":true},"categoricalBarChartSettings":{"categoryAxis":"Application","categoryAxisLabel":"Application","valueAxis":"Apdex","valueAxisLabel":"Apdex"}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}},"43":{"type":"code","title":"MTTR (Minutes)","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getProblemsList() {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const response = await problemsClient.getProblems({\n    from: startTime,to: endTime, problemSelector: \"status(Closed)\"\n  });\n  const result = await response;\n  return result.problems;\n}\n\nfunction expandArray(array) {\n  if (array.length == 1) {\n    return array[0].name;\n  } else if (array.length > 1) {\n    var retVal = \"\"\n    for (let i=0;i<array.length;i++) {\n      if (i!=0) {\n        retVal = retVal + \", \" + array[i].name;\n      } else {\n        retVal = array[i].name;\n      }\n    }\n    return retVal;\n  }\n  return \"\"; \n}\n\nexport default async function () {\n  const response = await getProblemsList();\n  const problems=response;\n  const types = [{\n      mappings: {\n        startTime: {type: 'timestamp'},\n        status: {type: 'string'},\n        displayId: {type: 'string'},\n        title: {type: 'string'},\n        impactLevel: {type: 'string'},\n        severityLevel: {type: 'string'},\n        affectedEntities: {type: 'string'},\n        impactedEntities: {type: 'string'},\n        rootCauseEntity: {type: 'string'},\n        duration: {type: 'double'},\n        \"event.id\": {type: 'string'},\n        endTime: {type: 'timestamp'}\n        },\n        indexRange: [\n        0,\n        problems.length\n      ]\n  }]\n  // Create a new empty data frame for the result\n  const dataFrame = {\n    records: [],\n    types: types\n  }\n  var mttr = 0;\n  for(let i=0; i<problems.length; i++) {\n      const problem = problems[i];\n      var duration = \"\";\n      if (problem.endTime == null || problem.endTime == \"\" || problem.endTime < 0) {\n        duration = Math.round(((Date.now() - problem.startTime)/1000)/60);\n      } else {\n        duration = Math.round(((problem.endTime-problem.startTime)/1000)/60);\n      }\n      mttr = mttr + duration;\n      var pstatus = \"\";\n      if (problem.status == 'OPEN') {\n        pstatus = \"游댮 OPEN\";\n      } else {\n        pstatus = '游릭 CLOSED';\n      }\n      var affectedEntities = expandArray(problem.affectedEntities);\n      var impactedEntities = expandArray(problem.impactedEntities);\n      var rootCause = \"\";\n      if (problem.rootCauseEntity == null) {\n        rootCause = \"\"\n      } else {\n        rootCause = problem.rootCauseEntity[\"name\"];\n      }\n       const record = {\n              startTime: problem.startTime,\n              status: pstatus,\n              displayId: problem.displayId,\n              title: problem.title,\n              impactLevel: problem.impactLevel,\n              severityLevel: problem.severityLevel,\n              affectedEntities: affectedEntities,\n              impactedEntities: impactedEntities,\n              rootCauseEntity: rootCause,\n              duration: duration,\n              \"event.id\": problem.problemId,\n              endTime: problem.endTime\n            }\n        dataFrame.records.push(record);\n    }\n//  return dataFrame;\n  return mttr/problems.length;\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"49":{"type":"code","title":"Host ($HostKPI)","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\nexport default async function () {\n  const timeout = 60;\n  const query = `timeseries {metricKey}Array = avg(dt.host.{metricKey}.usage), from:\"{from}\", to:\"{to}\"\n| fieldsAdd {metricKey} = arrayAvg({metricKey}Array)`.replaceAll(\"{metricKey}\",$HostKPI).replace(\"{from}\",$dt_timeframe_from).replace(\"{to}\",$dt_timeframe_to);\n  const response = await queryExecutionClient.queryExecute({ body: { query, requestTimeoutMilliseconds: timeout * 1000, fetchTimeoutSeconds: timeout  } });\n\n  return response.result;\n}","visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{},"legend":{"hidden":true}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}},"51":{"type":"code","title":"Application (User Experience )","input":"import { rumUserSessionsClient } from \"@dynatrace-sdk/client-classic-environment-v1\";\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  // Calculate Chart Interval\n  const timeDiff = (endTime-startTime)/3600/1000/24;\n  var chartInterval = \"30m\"\n  if (timeDiff>.5)\n    var chartInterval = \"1h\"\n  if (timeDiff>1)\n    var chartInterval = \"1d\"\n  const query = 'SELECT DATETIME(endTime,  \"MM-dd HH:mm:ss\",\"'+chartInterval+'\") AS \"Date\", CONDITION(count(*), where userExperienceScore=\"SATISFIED\")  AS \"Satisfied\", CONDITION(count(*), where userExperienceScore=\"TOLERATED\")  AS \"Tolerated\", CONDITION(count(*), where userExperienceScore=\"FRUSTRATED\")  AS \"Frustrated\" from usersession WHERE usersession.starttime>='+startTime+' and usersession.endtime<='+endTime+' GROUP BY  DATETIME(endTime,  \"MM-dd HH:mm:ss\",\"'+chartInterval+'\") limit 5000';\n  const response = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  const sampleCount = response.values.length;\n  return {\n    records: new Array(sampleCount).fill(null).map((_, index, array) => {\n      return {\n        Date: response.values[index][0],\n        'Satisfied': (response.values[index][1]),\n        'Tolerated': response.values[index][2],\n        'Frustrated': response.values[index][3]\n      };\n    }),\n    types: [\n      {\n        indexRange: [0, sampleCount],\n        mappings: {\n         Date: { type: 'timestamp' },\n          'Satisfied': { type: 'double' },\n          'Tolerated': { type: 'double' },\n          'Frustrated': { type: 'double' }\n        },\n      },\n    ],\n  };\n}","visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{},"seriesOverrides":[{"seriesId":["Tolerated"],"override":{"color":"#FFFF00"}},{"seriesId":["Satisfied"],"override":{"color":"#008000"}},{"seriesId":["Frustrated"],"override":{"color":"#FF0000"}}],"legend":{"hidden":true},"categoricalBarChartSettings":{"categoryAxis":"Application","categoryAxisLabel":"Application","valueAxis":"Apdex","valueAxisLabel":"Apdex"}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}},"52":{"type":"code","title":"Application (Avg $ApplicationKPI)","input":"import { rumUserSessionsClient } from '@dynatrace-sdk/client-classic-environment-v1';\nexport default async function () {\n  const startTime = Date.parse($dt_timeframe_from).toString();  // Get Dashboard Start Time\n  const endTime = Date.parse($dt_timeframe_to).toString();      // Get Dashboard End Time\n  const query = 'SELECT avg('+$ApplicationKPI+') FROM useraction where starttime>='+startTime+' and endtime<='+endTime;\n  const result = await rumUserSessionsClient.getUsqlResultAsTable({query: query, startTimestamp: startTime, endTimestamp: endTime});\n  return (result[\"values\"][0][0]).toFixed(2)/1000;\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":false,"sparklineSettings":{"isVisible":false},"alignment":"start"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{}}}},"53":{"type":"code","title":"Service ($ServiceKPI)","input":"/*\n* This function will run in the DYNATRACE JavaScript runtime.\n* For information visit https://dt-url.net/functions-help\n*/\nimport { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function () {\n\n  var metric_key = \"builtin:service.errors.total.rate\"\n  const data_type = \"double\"\n\n  if ($ServiceKPI==\"ResponseTime\") metric_key = \"builtin:service.response.time\";\n  \n  // Request Config\n  const config = {\n    metricSelector: buildQuery(metric_key),\n    resolution: \"10m\",\n    from: $dt_timeframe_from,\n    to: $dt_timeframe_to,\n    acceptType: \"application/json; charset=utf-8\"\n  }\n\n  // Safety Precaution\n  if (config.metricSelector.length > 3500) {\n    return (\"Please select fewer services\")\n  }\n\n  // Metric Request\n  const metric_query = await metricsClient.query(config);\n\n  // var shortcut\n  const data = metric_query.result[0].data\n\n  // ??\n  data.forEach(obj => {\n    obj.values = obj.values.map(value => value === null ? 0 : value);\n  });\n\n  // ??\n  const mergedData: MergedData = {};\n  data.forEach((item) => {\n    const { dimensionMap, timestamps, values } = item;\n    const serviceName = dimensionMap[\"dt.entity.service.name\"];\n    const serviceId = dimensionMap[\"dt.entity.service\"];\n    timestamps.forEach((timestamp, index) => {\n      if (!mergedData[timestamp]) {\n        mergedData[timestamp] = {};\n      }\n      const serviceKey = `${serviceName} - ${serviceId}`;\n      mergedData[timestamp][serviceKey] = values[index];\n    });\n  });\n\n  // Merge service data\n  const mergedData2 = {};\n  const lib = Object.keys(mergedData);\n  lib.forEach(obj => {\n    const lib2 = Object.keys(mergedData[obj]);\n    let val = 0;\n    lib2.forEach(obj2 => {\n      val += mergedData[obj][obj2];\n    });\n    mergedData2[obj] = {\n      \"All Services\": val/lib2.length\n    };\n  });\n  \n  // Chart config + data + mapping\n  const mappings = {\n    timestamp: { type: 'timestamp' },\n  };\n  for (const item of data) {\n    mappings[\"All Services\"] = { type: data_type };    \n  }\n  const output = {\n    records: Object.entries(mergedData2).map(([timestamp, services]) => ({\n      timestamp: parseInt(timestamp),\n      ...services,\n    })),\n    types: [\n      {\n        indexRange: [0, data[0].timestamps.length - 1],\n        mappings,\n      },\n    ],\n  };   \n  return output;\n}\n\n// ?? Aggregate metrics - Not Used\nfunction combineData(input: any[]): any {\n  const records: any[] = [];\n  const mappings: any = {};\n\n  for (const item of input) {\n    const { dimensionMap, timestamps, values, dimensions } = item;\n\n    for (let i = 0; i < timestamps.length; i++) {\n      const timestamp = timestamps[i].toString();\n      const record: any = { timestamp };\n\n      for (let j = 0; j < dimensions.length; j++) {\n        const dimension = dimensions[j];\n        const value = values[i * dimensions.length + j];\n        record[dimension] = value || 0;\n\n        if (!mappings[dimension]) {\n          mappings[dimension] = { type: typeof value === 'number' ? 'double' : 'unknown' };\n        }\n      }\n\n      records.push(record);\n    }\n  }\n  const types: any[] = [{\n    indexRange: [0, records.length],\n    mappings\n  }];\n  console.log(\"records:\");\n  console.log(records);\n  return { records, types };\n}\n\n// Build Metric Query\nfunction buildQuery(metricKey: string): string {\n  //const filterString = `\"in(\"dt.entity.service\",entitySelector(\"type(service)\"))\"`\n  //return `${metricKey}:filter(${filterString}):splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n  return `${metricKey}:splitBy(\"dt.entity.service\"):sort(value(auto,descending)):names`;\n}","visualization":"areaChart","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{},"seriesOverrides":[],"legend":{"hidden":true}},"singleValue":{"showLabel":true,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"lineWrapIds":[],"columnWidths":{}}}},"54":{"type":"code","title":"Log Error Rate","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\nexport default async function () {\n  \n  const timeout = 60;\n  const query = 'fetch logs, timeframe:\"'+$dt_timeframe_from+'/'+$dt_timeframe_to+'\" | summarize {logCount = count(), errorCount = countIf(status == \"ERROR\")} | fieldsAdd errorRate = (toDouble(errorCount) / toDouble(logCount)) * 100 | fields errorRate';\n  const query_response = await queryExecutionClient.queryExecute({ body: { query, requestTimeoutMilliseconds: timeout * 1000, fetchTimeoutSeconds: timeout  } });\n  const errorRate = parseInt(query_response.result[\"records\"][0][\"errorRate\"]);\n\n  return errorRate+\" %\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{},"lineWrapIds":[]}}},"55":{"type":"code","title":"Log Health","input":"import { queryExecutionClient } from '@dynatrace-sdk/client-query';\nexport default async function () {  \n  const timeout = 60;\n  const query = 'fetch logs, timeframe:\"'+$dt_timeframe_from+'/'+$dt_timeframe_to+'\" | summarize {logCount = count(), errorCount = countIf(status == \"ERROR\")} | fieldsAdd errorRate = (toDouble(errorCount) / toDouble(logCount)) * 100 | fields errorRate';\n  const query_response = await queryExecutionClient.queryExecute({ body: { query, requestTimeoutMilliseconds: timeout * 1000, fetchTimeoutSeconds: timeout  } });\n  const errorRate = parseInt(query_response.result[\"records\"][0][\"errorRate\"]);\n  if (errorRate>10) return \"游댮\";\n  if (errorRate>3) return \"游리\";\n  return \"游릭\";\n}","visualization":"singleValue","visualizationSettings":{"thresholds":[],"chartSettings":{"gapPolicy":"connect","circleChartSettings":{"groupingThresholdType":"absolute"},"categoryOverrides":{}},"singleValue":{"showLabel":false,"label":"","prefixIcon":"","autoscale":true,"alignment":"center"},"table":{"rowDensity":"condensed","enableSparklines":false,"hiddenColumns":[],"columnWidths":{},"lineWrapIds":[]}}},"56":{"type":"markdown","title":"","content":"[**Help**](https://github.com/TechShady/Dynatrace-Dashboards-Gen3/blob/main/ReadMeOperationalHealth.md#user-guide)"}},"layouts":{"9":{"x":0,"y":0,"w":24,"h":1},"10":{"x":0,"y":3,"w":24,"h":1},"12":{"x":0,"y":1,"w":8,"h":2},"14":{"x":0,"y":10,"w":24,"h":1},"20":{"x":8,"y":1,"w":2,"h":2},"24":{"x":10,"y":1,"w":2,"h":2},"25":{"x":21,"y":4,"w":3,"h":3},"26":{"x":16,"y":1,"w":2,"h":2},"27":{"x":21,"y":7,"w":3,"h":3},"28":{"x":18,"y":1,"w":2,"h":2},"32":{"x":0,"y":11,"w":24,"h":5},"33":{"x":0,"y":16,"w":22,"h":1},"34":{"x":22,"y":1,"w":2,"h":2},"36":{"x":20,"y":1,"w":2,"h":2},"37":{"x":12,"y":1,"w":2,"h":2},"38":{"x":9,"y":7,"w":3,"h":3},"39":{"x":12,"y":7,"w":3,"h":3},"41":{"x":6,"y":4,"w":3,"h":3},"42":{"x":0,"y":4,"w":6,"h":3},"43":{"x":9,"y":4,"w":3,"h":3},"49":{"x":15,"y":4,"w":6,"h":3},"51":{"x":0,"y":7,"w":6,"h":3},"52":{"x":6,"y":7,"w":3,"h":3},"53":{"x":15,"y":7,"w":6,"h":3},"54":{"x":12,"y":4,"w":3,"h":3},"55":{"x":14,"y":1,"w":2,"h":2},"56":{"x":22,"y":16,"w":2,"h":1}}}